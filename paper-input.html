<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
 * @module Quantum Paper Elements
 */
/**
 * paper-input is a single-line text field where user can enter input. It can optionally have
 * a label.
 *
 * Example:
 *
 *    <paper-input label="Your Name"></paper-input>
 *
 * @element paper-input
 * @homepage github.io
 */
-->
<link href="../polymer/polymer.html" rel="import">

<polymer-element name="paper-input" attributes="value label floatingLabel validate error" on-pointerdown="{{pointerdownAction}}" on-pointerup="{{pointerupAction}}">

  <template>

    <link href="paper-input.css" rel="stylesheet">

    <template if="{{floatingLabel}}">
      <div id="floatedLabel" class="hidden">{{label}}</div>
    </template>

    <span id="inputClone" aria-hidden="true">{{value}}</span>

    <div id="container" on-transitionend="{{transitionEndAction}}" on-webkitTransitionEnd="{{transitionEndAction}}">

      <div id="label">{{label}}</div>

      <input id="input" value="{{value}}" on-focus="{{focusAction}}" on-blur="{{blurAction}}" on-keypress="{{keypressAction}}" aria-labelledby="label" aria-invalid="{{_invalid}}">

      <div id="underline"></div>
      <div id="underlineHighlight" class="focusedColor"></div>

      <div id="caret">
        <div id="caretInner" class="focusedColor"></div>
      </div>

    </div>

    <template if="{{error}}">
      <div id="error" role="alert" aria-hidden="{{!_invalid}}">{{error}}</div>
    </template>

  </template>

  <script>

    Polymer('paper-input', {

      /**
       * The label for this input. It normally appears as grey text inside
       * the text input and disappears once the user enters text.
       *
       * @attribute label
       * @type string
       * @default ''
       */
      label: '',

      /**
       * If true, the label will "float" above the text input once the
       * user enters text instead of disappearing.
       *
       * @attribute floatingLabel
       * @type boolean
       * @default false
       */
      floatingLabel: false,

      /**
       * The value of this input.
       *
       * @attribute label
       * @type string
       * @default ''
       */
      value: '',

      /**
       * If this property is not null, the text input's value will be validated.
       * You can validate the value with either a regular expression or a
       * custom function.
       *
       * To use a regular expression, set this property to a RegExp object or
       * a string containing the regular expression to match against. To use a
       * custom validator, set this property to a function with the signature
       * function(value) that returns a boolean. The input is valid if the
       * function returns true.
       *
       * Example:
       *
       * <paper-input validate="^[0-9]*$"></paper-input> // valid only if the value is a number
       * 
       * this.$.paperInput.validator = /^[0-9]*$/;  // valid only if the value is a number
       *
       * this.$.paperInput2.validator = function(value) {
       *     return value === 'foo';  // valid only if the value is 'foo'
       * }
       *
       * @attribute validate
       * @type string|RegExp|Function(value)
       * @default null
       */
      validate: null,

      /**
       * The message to display when the input is invalid.
       *
       * @attribute error
       * @type string
       * @default ''
       */
      error: '',

      focused: false,
      pressed: false,

      ready: function() {
        if (this.value) {
          this.$.floatedLabel.classList.remove('hidden');
        }
        this._invalid = false;
      },

      validateValue: function() {
        var valid = true;
        if (!this.value) {
          valid = true;
        } else if (typeof this.validate === 'string') {
          valid = new RegExp(this.validate).exec(this.value);
        } else if (this.validate.exec) {
          valid = this.validate.exec(this.value);
        } else if (this.validate instanceof Function) {
          valid = this.validate.call(this.value);
        }
        this._invalid = !valid;
        this.classList.toggle('invalid', !valid);
      },

      valueChanged: function() {
        if (this.validate) {
          this.validateValue();
        }
      },

      focusAction: function(e) {
        if (!this.pressed) {
          if (this.floatingLabel) {
            this.$.floatedLabel.classList.remove('hidden');
            this.$.floatedLabel.classList.add('focused');
            this.$.floatedLabel.classList.add('focusedColor');
          }
          this.$.label.classList.add('hidden');
          this.$.underlineHighlight.classList.add('focused');
          this.$.caret.classList.add('focused');
          this.$.input.focus();
        }
        this.focused = true;
      },

      blurAction: function() {
        this.$.underlineHighlight.classList.remove('focused');
        this.$.caret.classList.remove('focused');
        if (this.floatingLabel) {
          this.$.floatedLabel.classList.remove('focused');
          this.$.floatedLabel.classList.remove('focusedColor');
          if (!this.value) {
            this.$.floatedLabel.classList.add('hidden');
          }
        }
        if (!this.value) {
          this.$.label.classList.remove('hidden');
        }
        this.focused = false;
      },

      pointerdownAction: function(e) {
        if (this.focused) {
          return;
        }
        this.pressed = true;
        var rect = this.$.underline.getBoundingClientRect();
        var right = e.x - rect.left;
        this.$.underlineHighlight.style.webkitTransformOriginX = right + 'px';
        this.$.underlineHighlight.classList.remove('focused');
        this.underlineAsync = this.async(function() {
          this.$.underlineHighlight.classList.add('pressed');
        }, null, 200);

        // No caret animation if there is text in the input.
        if (!this.value) {
          var width = this.$.inputClone.getBoundingClientRect().width;
          if (width < right) {
            this.$.caret.style.left = width + 'px';
            this.$.caret.classList.remove('focused');
          }
        }
      },

      pointerupAction: function() {
        if (!this.pressed) {
          return;
        }
        if (this.underlineAsync) {
          clearTimeout(this.underlineAsync);
          this.underlineAsync = null;
        }

        // Focus the input here to bring up the virtual keyboard.
        this.$.input.focus();
        this.pressed = false;
        this.animating = true;

        this.$.underlineHighlight.classList.remove('pressed');
        this.$.underlineHighlight.classList.add('animating');
        this.async(function() {
          this.$.underlineHighlight.classList.add('focused');
        });

        // No caret animation if there is text in the input.
        if (!this.value) {
          this.$.caret.classList.add('animating');
          this.async(function() {
            this.$.caret.classList.add('focused');
          }, null, 100);
        }

        if (this.floatingLabel) {
          this.$.label.classList.add('focusedColor');
          this.$.label.classList.add('animating');
        }
      },

      keypressAction: function() {
        if (this.animating) {
          this.transitionEndAction();
        }
      },

      transitionEndAction: function(e) {
        this.animating = false;
        if (this.pressed) {
          return;
        }
        this.$.label.classList.add('hidden');
        this.$.label.classList.remove('focusedColor');
        if (this.floatingLabel) {
          this.$.label.classList.remove('animating');
          this.$.floatedLabel.classList.remove('hidden');
          this.$.floatedLabel.classList.add('focused');
          this.$.floatedLabel.classList.add('focusedColor');
        }
        this.async(function() {
          this.$.underlineHighlight.classList.remove('animating');
          this.$.caret.classList.remove('animating');
        }, null, 100);
      }

    });

  </script>

</polymer-element>
