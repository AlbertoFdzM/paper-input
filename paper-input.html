<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE
The complete set of authors may be found at http://polymer.github.io/AUTHORS
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS
-->

<!--
/**
 * paper-input is a single- or multi-line text field where user can enter input.
 * It can optionally have a label.
 *
 * Example:
 *
 *    <paper-input label="Your Name"></paper-input>
 *    <paper-input multiline label="Enter multiple lines here"></paper-input>
 *
 * @group Quantum Paper Elements
 * @element paper-input
 * @homepage github.io
 */
/**
 * Fired when the value of the input is changed. This is the same event as the DOM
 * "input" event.
 *
 * @event input
 */
/**
 * Fired when the user commits the value of the input, either by the hitting the
 * <enter> key or blurring the input after the changing the value. Also see the
 * DOM "change" event.
 *
 * @event change
 */
-->
<link href="../polymer/polymer.html" rel="import">

<polymer-element name="paper-input" attributes="value label floatingLabel disabled multiline validate error" on-pointerdown="{{pointerdownAction}}" on-pointerup="{{pointerupAction}}">

  <template>

    <link href="paper-input.css" rel="stylesheet">

    <div id="floatedLabel" class="hidden"><span id="floatedLabelSpan">{{label}}</span></div>

    <div id="container" on-transitionend="{{transitionEndAction}}" on-webkitTransitionEnd="{{transitionEndAction}}">

      <div id="label"><span id="labelSpan">{{label}}</span></div>

      <div id="inputContainer">

        <div id="inputClone">
          <span id="inputCloneSpan" aria-hidden="true">&nbsp;</span>
        </div>

        <template if="{{multiline}}">
          <textarea id="input" value="{{value}}" rows="1" disabled?="{{disabled}}" on-focus="{{focusAction}}" on-blur="{{blurAction}}" on-keypress="{{keypressAction}}" aria-labelledby="label" aria-invalid="{{_invalid}}"></textarea>
        </template>

        <template if="{{!multiline}}">
          <input id="input" value="{{value}}" disabled?="{{disabled}}" on-focus="{{focusAction}}" on-blur="{{blurAction}}" on-keypress="{{keypressAction}}" on-change="{{inputChangeAction}}" aria-labelledby="label" aria-invalid="{{_invalid}}">
        </template>

      </div>

      <div id="underlineContainer">
        <div id="underline"></div>
        <div id="underlineHighlight" class="focusedColor"></div>
      </div>

      <div id="caret">
        <div id="caretInner" class="focusedColor"></div>
      </div>

    </div>

    <div id="errorContainer">
      <div id="error" role="alert" aria-hidden="{{!_invalid}}">{{error}}</div>
      <div id="errorIcon"></div>
    </div>

  </template>

  <script>

    Polymer('paper-input', {

      /**
       * The label for this input. It normally appears as grey text inside
       * the text input and disappears once the user enters text.
       *
       * @attribute label
       * @type string
       * @default ''
       */
      label: '',

      /**
       * If true, the label will "float" above the text input once the
       * user enters text instead of disappearing.
       *
       * @attribute floatingLabel
       * @type boolean
       * @default false
       */
      floatingLabel: false,

      /**
       * If true, this input cannot be focused and the user cannot change
       * its value.
       *
       * @attribute disabled
       * @type boolean
       * @default false
       */
      disabled: false,

      /**
       * If true, this input accepts multi-line input like a <textarea>
       *
       * @attribute multiline
       * @type boolean
       * @default false
       */
      multiline: false,

      /**
       * The value of this input.
       *
       * @attribute label
       * @type string
       * @default ''
       */
      value: '',

      /**
       * If this property is not null, the text input's value will be validated.
       * You can validate the value with either a regular expression or a
       * custom function.
       *
       * To use a regular expression, set this property to a RegExp object or
       * a string containing the regular expression to match against. To use a
       * custom validator, set this property to a function with the signature
       * function(value) that returns a boolean. The input is valid if the
       * function returns true.
       *
       * Example:
       *
       * <paper-input validate="^[0-9]*$"></paper-input> // valid only if the value is a number
       * 
       * this.$.paperInput.validator = /^[0-9]*$/;  // valid only if the value is a number
       *
       * this.$.paperInput2.validator = function(value) {
       *     return value === 'foo';  // valid only if the value is 'foo'
       * }
       *
       * @attribute validate
       * @type string|RegExp|Function(value)
       * @default null
       */
      validate: null,

      /**
       * The message to display when the input is invalid.
       *
       * @attribute error
       * @type string
       * @default ''
       */
      error: '',

      focused: false,
      pressed: false,

      ready: function() {
        if (this.value) {
          this.$.floatedLabel.classList.remove('hidden');
        }
        this._invalid = false;
      },

      attached: function() {
        this.multilineChanged();
      },

      validateValue: function() {
        var valid = true;
        if (!this.value) {
          valid = true;
        } else if (typeof this.validate === 'string') {
          valid = new RegExp(this.validate).exec(this.value);
        } else if (this.validate.exec) {
          valid = this.validate.exec(this.value);
        } else if (this.validate instanceof Function) {
          valid = this.validate.call(this.value);
        }
        this._invalid = !valid;
        this.classList.toggle('invalid', !valid);
      },

      multilineChanged: function() {
        if (this.multiline) {
          this.$.underlineContainer.style.top = this.$.inputClone.getBoundingClientRect().height - 1 + 'px';
        }
      },

      valueChanged: function() {
        if (this.multiline) {
          var escaped = this.value.replace(/\n/gm, '<br>');
          if (!escaped || escaped.lastIndexOf('<br>') === escaped.length - 4) {
            escaped += '&nbsp';
          }
          this.$.inputCloneSpan.innerHTML = escaped;

          this.$.underlineContainer.style.top = this.$.inputClone.getBoundingClientRect().height - 1 + 'px';
        }

        if (this.validate) {
          this.validateValue();
        }

        if (!this.floatingLabel) {
          this.$.label.classList.toggle('hidden', this.value);
        }
      },

      labelChanged: function() {
        if (this.floatingLabel && this.$.floatedLabel && this.$.label) {
          var toRect = this.$.floatedLabelSpan.getBoundingClientRect();
          var fromRect = this.$.labelSpan.getBoundingClientRect();
          this.$.label.cachedTransform = 'scale(' + (toRect.width / fromRect.width) + ') ' +
            'translateY(' + (toRect.bottom - fromRect.bottom) + 'px)'
        }
      },

      focusAction: function(e) {
        if (!this.pressed) {
          if (this.floatingLabel) {
            this.$.floatedLabel.classList.remove('hidden');
            this.$.floatedLabel.classList.add('focused');
            this.$.floatedLabel.classList.add('focusedColor');
          }
          this.$.label.classList.add('hidden');
          this.$.underlineHighlight.classList.add('focused');
          this.$.caret.classList.add('focused');
          this.$.input.focus();
        }
        this.focused = true;
      },

      blurAction: function() {
        this.$.underlineHighlight.classList.remove('focused');
        this.$.caret.classList.remove('focused');
        if (this.floatingLabel) {
          this.$.floatedLabel.classList.remove('focused');
          this.$.floatedLabel.classList.remove('focusedColor');
          if (!this.value) {
            this.$.floatedLabel.classList.add('hidden');
          }
        }
        if (!this.value) {
          this.$.label.classList.remove('hidden');
          this.$.label.classList.add('animating');
          this.async(function() {
            this.$.label.style.webkitTransform = 'none';
          });
        }
        this.focused = false;
      },

      pointerdownAction: function(e) {
        if (this.disabled) {
          return;
        }

        if (this.focused) {
          return;
        }

        this.pressed = true;
        var rect = this.$.underline.getBoundingClientRect();
        var right = e.x - rect.left;
        this.$.underlineHighlight.style.webkitTransformOriginX = right + 'px';
        this.$.underlineHighlight.classList.remove('focused');
        this.underlineAsync = this.async(function() {
          this.$.underlineHighlight.classList.add('pressed');
        }, null, 200);

        // No caret animation if there is text in the input.
        if (!this.value) {
          var width = this.$.inputCloneSpan.getBoundingClientRect().width;
          if (width < right) {
            this.$.caret.style.left = width + 'px';
            this.$.caret.classList.remove('focused');
          }
        }
      },

      pointerupAction: function() {
        if (this.disabled) {
          return;
        }

        if (!this.pressed) {
          return;
        }
        
        if (this.underlineAsync) {
          clearTimeout(this.underlineAsync);
          this.underlineAsync = null;
        }

        // Focus the input here to bring up the virtual keyboard.
        this.$.input.focus();
        this.pressed = false;
        this.animating = true;

        this.$.underlineHighlight.classList.remove('pressed');
        this.$.underlineHighlight.classList.add('animating');
        this.async(function() {
          this.$.underlineHighlight.classList.add('focused');
        });

        // No caret animation if there is text in the input.
        if (!this.value) {
          this.$.caret.classList.add('animating');
          this.async(function() {
            this.$.caret.classList.add('focused');
          }, null, 100);
        }

        if (this.floatingLabel) {
          this.$.label.classList.add('focusedColor');
          this.$.label.classList.add('animating');
          this.$.label.style.webkitTransform = this.$.label.cachedTransform;
        }
      },

      keypressAction: function() {
        if (this.animating) {
          this.transitionEndAction();
        }
      },

      transitionEndAction: function(e) {
        this.animating = false;
        if (this.pressed) {
          return;
        }

        if (this.focused) {

          if (this.floatingLabel || this.value) {
            this.$.label.classList.add('hidden');
          }

          if (this.floatingLabel) {
            this.$.label.classList.remove('focusedColor');
            this.$.label.classList.remove('animating');
            this.$.floatedLabel.classList.remove('hidden');
            this.$.floatedLabel.classList.add('focused');
            this.$.floatedLabel.classList.add('focusedColor');
          }

          this.async(function() {
            this.$.underlineHighlight.classList.remove('animating');
            this.$.caret.classList.remove('animating');
          }, null, 100);

        } else {

          this.$.label.classList.remove('animating');

        }
      },

      inputChangeAction: function(e) {
        this.fire('change', null, this, false);
      }

    });

  </script>

</polymer-element>
